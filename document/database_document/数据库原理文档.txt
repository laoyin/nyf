数据库文档

1-1. postgres 原理简介

1. postgres 进程结构

1.1 一个用户具有一个进程

1.2 进程结构 
postgres 运行是进程列表 
postgres  2557     1  0 14:15 ?        00:00:00 /usr/local/pgsql/bin/postmaster -D /db/pgsql/data
postgres  2611  2557  0 14:15 ?        00:00:00 postgres: checkpointer process                   
postgres  2612  2557  0 14:15 ?        00:00:02 postgres: writer process                         
postgres  2613  2557  0 14:15 ?        00:00:00 postgres: wal writer process                     
postgres  2614  2557  0 14:15 ?        00:00:01 postgres: autovacuum launcher process            
postgres  2615  2557  0 14:15 ?        00:00:00 postgres: stats collector process        

1.3 连接 的生命周期 
1. master 在5432端口监听
2. client 连接服务器
3. 认证
4. 启动一个进程
5. 回调到客户端
6. 客户端发送查询
7. 取数据
8. 返回结果到客户端
9. 客户端关闭连接
10. 关闭进程

2.  内存结构

3. 存储结构

3.1 表空间保存数据文件

3.2 一个表保存在一个文件

3.3 如果表数据超过1Ｇ则保存在多个文件(segment)

3.4 文件(segment)被划分成多个块(block 8K)

3.5 数据块结构
页头 指针 行数据 特殊
指针指向行数据

4.  postgres 事务处理机制

4.1 事务的ACID属性

1. 原子性（Atomicity）
原子性是指事务是一个不可分割的工作单位，事务中的操作要么都发生，要么都不发生。
 
2. 一致性（Consistency）
事务必须使数据库从一个一致性状态变换到另外一个一致性状态。

3. 隔离性（Isolation）
事务的隔离性是指一个事务的执行不能被其他事务干扰，即一个事务内部的操作及使用的数据对并发的其他事务是隔离的，并发执行的各个事务之间不能互相干扰。

4. 持久性（Durability）
持久性是指一个事务一旦被提交，它对数据库中数据的改变就是永久性的，接下来的其他操作和数据库故障不应该对其有任何影响。
 
4.2 5种状态
 
1. 活动状态
事务在执行时的状态叫活动状态。

2. 部分提交状态
事务中最后一条语句被执行后的状态叫部分提交状态。

3. 失败状态
事务不能正常执行的状态叫失败状态。

4. 提交状态
事务在部分提交后，将往硬盘上写入数据，当最后一条信息写入后的状态叫提交状态。进入提交状态的事务就成功完成了。

5. 中止状态
事务回滚并且数据库已经恢复到事务开始执行前的状态叫中止状态。

4.3 postgres 事务处理机制

1.  事务的4个特征ACID及响应的实现技术
ACID          实现技术
原子性       MVCC(多版本并发控制)
一致性       约束（主键，外键等）
隔离性       MVCC
持久性       WAL(预写式事务日志)

2. MVCC(多版本并发控制)

MVCC(Multiversion Concurrency Control)即多版本并发控制，它可以避免读写事务之间的互相阻塞，相比通常的封锁技术可极大的提高业务的并发性能。PostgreSQL中的MVCC实现原理可简单概括如下：
1）数据文件中存放同一逻辑行的多个行版本（称为Tuple）
2）每个行版本的头部记录创建以及删除该行版本的事务的ID（分别称为xmin和xmax）
3）每个事务的状态（运行中，中止或提交）记录在pg_clog文件中
4）根据上面的数据并运用一定的规则每个事务只会看到一个特定的行版本
通过MVCC读写事务可以分别在不同的行版本上工作，因此能够在互不冲突的情况下并发执行。

3. WAL(预写式事务日志)

当系统意外宕机后，恢复时需要回退未完成事务所做的更改并确保已提交事务所作的更改均已生效。在PostgreSQL中通过前面提到的MVCC很容易做到的第一点，只要把所有pg_clog文件中记录的所有“运行中”的事务的状态置为“中止”即可，这些事务在宕机时都没有结束。对于第二点，必须确保事务提交时修改已真正写入到永久存储中。但是直接刷新事务修改后的数据到磁盘是很费时的，为解决这个问题于是引入了WAL(Write-Ahead Log)。
WAL的基本原理如下：
1）更新数据页前先将更新内容记入WAL日志
2）异步刷新数据Buffer的脏页和WAL Buffer到磁盘
3）Buffer管理器确保绝不会先于对应的WAL记录刷新脏数据到磁盘
4）事务提交时，将WAL日志同步刷新到磁盘
5）Checkpoint发生时，将数据Buffer的所有脏页刷新到磁盘


